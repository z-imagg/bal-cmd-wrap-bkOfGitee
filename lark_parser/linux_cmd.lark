// grammar gcc_cmd

start: gcc_cmd

///////////非终结符
gcc_cmd: gcc_cmd_1  | gcc_cmd_3 | gcc_cmd_2 | gcc_cmd_4
//gcc_cmd: lark 将 先 gcc_cmd_1 后 gcc_cmd_3
gcc_cmd_1: program kv_ls src_file
//gcc_cmd_1: gcc编译源代码命令，比如 gcc -c -o User.o User.c, 其中 src_file 就是 User.c
gcc_cmd_2: program kv_ls
//gcc_cmd_2: 末尾不跟文件, 不确定有没有这种形式
gcc_cmd_4: program kv_ls input_is_std_in
//gcc_cmd_4: 末尾不跟文件, 跟 一个 单独的中划线 （表示从终端读取输入）
gcc_cmd_3: program kv_ls file+
//gcc_cmd_3: gcc链接命令 ； 比如  多个.o文件 链接为 单个.so 文件 ，具体例子 比如  gcc -o xxx.so User.o Util.o Price.o，其中 file+ 就是 【Util.o Price.o】

input_is_std_in: DASH
program: FILE_NAME
src_file: FILE_NAME
file: FILE_NAME

kv_ls: kv*
//     空格spc                                                                             |        无间隔符__                                                |                                   非空格间隔符 【模糊argName的kv优先级最低，即 kv_k_eq_valnorm 、 kv_k_comma_valany优先级最低】                         |         有选项名但无选项值
kv: kv_i_spc_incpth|kv_i_spc_includepth |kv_isystem_spc_valnorm | kv_k_spc_valnorm        | kv_i__incpth|kv_d__valany |kv_w__valany|kv_f__valany| kv_k__str |kv_std_eq_valany|   kv_march_eq_valany | kv_std_eq_valany |kv_w_eq_valany| kv_d_eq_valany|kv_f_eq_valany | kv_k_eq_valnorm | kv_k_comma_valany  |         kv_m_dd | key
//kv_i_spc_incpth"-I xxx" 得比 kv_i__incpth"-Ixxx" 优先级高
//kv : kv_I_incPth(即 -Ixxx) 必须 比 key 靠前, 否则 kv_I_incPth(即 -Ixxx) 会被 key 淹没

//各种 选项名_选项值 样式
kv_k_spc_valnorm: key sep_spc VAL_NORMAL
//kv_k_spc_valnorm : k v 之间的分割符 是  空格
kv_isystem_spc_valnorm: ARG_ISYSTEM sep_spc isystem_val
kv_k_eq_valnorm: key sep_eq VAL_NORMAL
//kv_k_eq_valnorm : k v 之间的分割符 是  等号
kv_k__str: key STR
//kv_k__str: 当v用引号包裹时, k v之间 不需要 分割符
kv_k_comma_valany: key sep_comma VAL_ANY
// kv_k_comma_valany: 当k v之间的分割符 为 逗号 时, v的形式是任意的
kv_i__incpth: ARG_INC inc_val
kv_i_spc_incpth: ARG_INC sep_spc sep_inc_val
// kv_i__incpth: 当k 是 -I  时, k v之间 不需要 分割符
kv_i_spc_includepth: ARG_INCLUDE sep_spc sep_include_val
kv_march_eq_valany: ARG_MARCH sep_eq m_arch_val
kv_m_dd: ARG_M m_dd_val
kv_std_eq_valany: ARG_STD sep_eq std_val
kv_d__valany: ARG_D d_val
kv_d_eq_valany: ARG_D sep_eq d_eq_val
kv_w__valany: ARG_W w_val
kv_w_eq_valany: ARG_W sep_eq w_eq_val
kv_f__valany: ARG_F f_val
kv_f_eq_valany: ARG_F sep_eq f_eq_val

//选项的名字
key: KEY

//选项的值
inc_val: VAL_NORMAL
sep_inc_val: VAL_NORMAL
sep_include_val: VAL_NORMAL
isystem_val : VAL_NORMAL
m_arch_val : VAL_NORMAL
std_val : VAL_NORMAL
m_dd_val : DD
d_val: VAL_ANY
d_eq_val: VAL_ANY
w_val: VAL_ANY
w_eq_val: VAL_ANY
f_val: VAL_ANY
f_eq_val: VAL_ANY
//kv_sep: KV_SEP

//分割符 （割开 选项名 和 选项值 ）
sep_eq: "="
sep_spc: " "+
sep_comma: ","

///////////////终结符
///选项的名字
ARG_STD: "-std"
ARG_D: "-D"
ARG_W: "-W"
ARG_F: "-f"
ARG_INC: "-I"
ARG_MARCH: "-march"
ARG_M: "-m"
ARG_INCLUDE: "-include"
ARG_ISYSTEM: "-isystem"
KEY: "-" ("-")? (L|D) ("-"|"_"|L|D)*
// KEY的定义中 末尾部分 '("-"|"_"|L|D)*' 如果少了 中划线 会导致   lack文法 linux_cmd.lark  bug : -Wno-trigraphs  错误的 被按-拆开成两个选项 -Wno 和 -trigraphs
DASH : "-"

///选项的值
VAL_NORMAL: TK_NORMAL |   STR
VAL_ANY: TK_ANY |   STR
STR: _STR | _STR_ESC
TK_NORMAL: /[_\/\.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789][-_\/\.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*/
// TK_NORMAL: 开头字符 只 比 后面字符 少 中划线
//正常单词: (开头字符)为 后字符 去掉 中划线 , (后跟 0个或多个) 字母 数字 中划线 下划线 正斜线 点
TK_ANY: (","|"-"|SL|L|D)+
DD: /[0-9]{2}/
//-M_DD: -m32 或 -m64 等

///更基础的定义
SL: "_"|"/"|"."|"="
D: "0".."9"
LL: "a".."z"
UL: "A".."Z"
L: LL | UL

_STR : _STR_DQ | _STR_SQ
_STR_INNER: /.*?/
//  .*?   匹配任意字符序列（除换行符外），但尽可能少地匹配（非贪婪模式）。
_STR_DQ : DQ _STR_INNER DQ
_STR_SQ : SQ _STR_INNER SQ
DQ :   "\""
//双引号 DOUBLE_QUOTATION 即 "
SQ :   "\'"
//单引号 SINGLE_QUOTATION 即 '


_STR_ESC : _STR_DQ_ESC | _STR_SQ_ESC
_STR_DQ_ESC : DQ_ESC _STR_INNER DQ_ESC
_STR_SQ_ESC : SQ_ESC _STR_INNER SQ_ESC

DQ_ESC :   "\\\""
//双引号转义符  DOUBLE_QUOTATION_ESCAPE 即 \"
SQ_ESC :   "\\\'"
//单引号转义符 SINGLE_QUOTATION_ESCAPE 即 \"

FILE_NAME: (FILE_NAME_LEAD | D | L) (FILE_NAME_MID | D | L)+
FILE_NAME_LEAD: "." | "_" | "," | "+" | "/"
FILE_NAME_MID: FILE_NAME_LEAD | "-"



///////忽略空格等
WS_INLN: (" "|/\t/)+
%ignore WS_INLN
